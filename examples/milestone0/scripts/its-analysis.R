#
# Usage:
#  R --no-restore --no-save --args dbschema user passwd [enddate [startdate] ] < its-analysis.R > script.out

# Get arguments from the command line
#
#  - dbschema: MySQL database schema to use, generated by CVSAnalY2
#  - user: MySQL user with permissions to access the schema
#  - passwd: password corresponding to user
#  - enddate: final date of the period to analyze. Format: YYYY-MM-DD
#      (in fact, first day after the period)
#  - startdate: starting date of the period to analyze. Format: YYYY-MM-DD
#
# Note: this script works with bicho databases obtained from Bugzilla

# Get command line args, and produce variables for the script
args <- commandArgs(trailingOnly = TRUE)
print(args)

database <- args[1]
user <- args[2]
password <- args[3]

if (length(args) > 3) {
   enddate <- args[4]
} else {
   enddate <- "2100-01-01"
}
enddatesplit <- strsplit(enddate,'-')
endyear <- enddatesplit[[1]][1]
endmonth <- enddatesplit[[1]][2]
enddate <- paste (c("'", enddate, "'"), collapse='')

if (length(args) > 4) {
   startdate <- args[5]
} else {
   startdate <- "1900-01-01"
}
startdatesplit <- strsplit(startdate,'-')
startyear <- startdatesplit[[1]][1]
startmonth <- startdatesplit[[1]][2]
startdate <- paste (c("'", startdate, "'"), collapse='')

library(rjson)
#
# Create a JSON file with some R object
#
createJSON <- function (data, filename) {
   sink(filename)
   cat(toJSON(data))
   sink()
}

library(RMySQL)
#
# Connect to the database and prepare...
#
mychannel <- dbConnect(MySQL(), user=user, password=password, host="localhost", db=database)
query <- function(...) dbGetQuery(mychannel, ...)

# To install RColorBrewer
# $sudo R
# > install.packages('RColorBrewer', dep = T)
# Exit R
library(RColorBrewer)

source("swscopio.R")

# Closed tickets: time ticket was open, first closed, time-to-first-close
q <- "SELECT issue_id, issue,
     	submitted_on as time_open,
        time_closed,
	time_closed_last,
	TIMESTAMPDIFF (DAY, submitted_on, ch.time_closed) AS ttofix
      FROM issues, (
         SELECT
           issue_id,
           MIN(changed_on) AS time_closed,
           MAX(changed_on) as time_closed_last
         FROM changes
         WHERE (new_value='RESOLVED' OR new_value='CLOSED')
         GROUP BY issue_id) ch
      WHERE issues.id = ch.issue_id"
res_issues_closed <- query(q)

# Closed tickets per week (using first closing date)
q <- "SELECT YEAR (time_closed) * 52 + WEEK (time_closed) AS yearweek,
        DATE_FORMAT(time_closed, '%Y %V') AS year_week,
	YEAR (time_closed) AS year,
        WEEK (time_closed) AS week,
        COUNT(*) as closed
      FROM (
         SELECT issue_id, MIN(changed_on) time_closed
         FROM changes 
         WHERE new_value='RESOLVED' OR new_value='CLOSED' 
         GROUP BY issue_id) ch 
      GROUP BY yearweek"
res_issues_w_closed <- query(q)

# Closed tickets per week (using last closing date)
q <- "SELECT YEAR (time_closed) * 52 + WEEK (time_closed) AS yearweek,
        DATE_FORMAT(time_closed, '%Y %V') AS year_week,
	YEAR (time_closed) AS year,
        WEEK (time_closed) AS week,
        COUNT(*) as closed_last
      FROM (
         SELECT issue_id, MAX(changed_on) time_closed
         FROM changes 
         WHERE new_value='RESOLVED' OR new_value='CLOSED' 
         GROUP BY issue_id) ch 
      GROUP BY yearweek"
res_issues_w_closed_last <- query(q)

# New tickets per week
q <- "SELECT YEAR (submitted_on) * 52 + WEEK (submitted_on) AS yearweek,
        DATE_FORMAT(submitted_on, '%Y %V') AS year_week,
	YEAR (submitted_on) AS year,
        WEEK (submitted_on) AS week,
        COUNT(*) AS open
      FROM issues
      GROUP BY yearweek"
res_issues_w_open <- query(q)

# Tickets open and closed (first close) per week
issues_open_closed_week <- mergeWeekly (res_issues_w_open, res_issues_w_closed)
plotTimeSerieWeekN (issues_open_closed_week, c("open", "closed"),
                    "its-open-closed-week", c("Tickets open", "closed"))

# Tickets open and closed (last close) per week
issues_open_closed_last_week <- mergeWeekly (res_issues_w_open,
			     		     res_issues_w_closed_last)
plotTimeSerieWeekN (issues_open_closed_last_week, c("open", "closed_last"),
                    "its-open-closed-last-week", c("Tickets open", "closed"))

# Tickets closed (first and last close) per week
issues_closed_week <- mergeWeekly (res_issues_w_closed,
			     		     res_issues_w_closed_last)
plotTimeSerieWeekN (issues_closed_week, c("closed", "closed_last"),
                    "its-closed-week",
		    c("Tickets closed first", "last"))

# Note use display.brewer.pal(...) to check colors
# example: display.brewer.pal(9, "Greens")

blues = brewer.pal(5,'Blues')
reds = brewer.pal(5,'Reds')
greens = brewer.pal(5,'Greens')


## TIME TO FIX

threshold = 30
all_closed <- res_issues_closed$ttofix
quick_closed <- res_issues_closed$ttofix[res_issues_closed$ttofix <= threshold]
slow_closed <- res_issues_closed$ttofix[res_issues_closed$ttofix > threshold]

# Distribution of time to fix (first close)
pdf('its-distrib_time_to_fix.pdf', height=3.5, width=5)
hist(all_closed, prob= T, breaks='FD', col=blues[3],
     xlab = 'Time to fix (days)', main = 'Time to fix bugs')
lines(density(all_closed), col=reds[3], lwd = 2)
dev.off()

# Distribution of time to fix (last close)
pdf('its-distrib_time_to_fix_last.pdf', height=3.5, width=5)
hist(all_closed, prob= T, breaks='FD', col=blues[3],
     xlab = 'Time to fix (days)', main = 'Time to fix bugs')
lines(density(all_closed), col=reds[3], lwd = 2)
dev.off()

# Distribution of time to fix (first close), quickly fixed bugs
pdf('its-distrib_time_to_fix_quick.pdf', height=3.5, width=5)
hist(quick_closed, prob= T, breaks='FD', col=blues[3],
     xlab = 'Time to fix (days)', main = 'Quickly fixed')
lines(density(quick_closed), col=reds[3], lwd = 2)
dev.off()

# Distribution of time to fix (first close), slowly fixed bugs
pdf('its-distrib_time_to_fix_slow.pdf', height=3.5, width=5)
hist(slow_closed, prob= T, breaks='FD', col=blues[3],
     xlab = 'Time to fix (days)', main = 'Slowly fixed')
lines(density(slow_closed), col=reds[3], lwd = 2)
dev.off()


pdf('its-boxplot_time_to_fix.pdf', height=3.5, width=5)
boxplot(res_issues_closed$ttofix, col = greens[2],
        main = "Time to fix bugs", ylab = "days", xlab = "Time to fix bugs")

# Mark top 3 outliers
top3 = rev(sort(res_issues_closed$ttofix))[1:3]
print(top3)

text(rep(1,3), y = top3,
     label = paste(top3, 'days'), pos = 4)
dev.off()



q <- paste ("SELECT year(submitted_on) * 12 + month(submitted_on) AS id,
               year(submitted_on) AS year,
               month(submitted_on) AS month,
	       DATE_FORMAT (submitted_on, '%b %Y') as date,
               count(submitted_by) AS open,
               count(distinct(submitted_by)) AS openers
             FROM issues
	     GROUP BY year,month
	     ORDER BY year,month")
open_monthly <- query(q)


# Closed tickets using changes
q <- paste ("SELECT year(changed_on) * 12 + month (changed_on) AS id,
               year(changed_on) as year,
               month(changed_on) as month,
	           DATE_FORMAT (changed_on, '%b %Y') as date,
               count(issue_id) AS closed,
               count(distinct(changed_by)) AS closers
             FROM changes
             WHERE new_value='RESOLVED' OR new_value='CLOSED' 
             GROUP BY year,month
  	     ORDER BY year,month")
closed_monthly <- query(q)

# OLD CLOSED QUERY USING DELTA_TS. Not correct.
# q <- paste ("SELECT year(delta_ts) * 12 + month(delta_ts) AS id,
#                year(delta_ts) AS year,
#                month(delta_ts) AS month,
# 	       DATE_FORMAT (delta_ts, '%b %Y') as date,
#                count(*) AS closed
# 	     FROM issues_ext_bugzilla, issues
#          WHERE issues.id = issues_ext_bugzilla.issue_id
#          AND delta_ts is not NULL
#          AND (status='RESOLVED' OR status='VERIFIED')
#          GROUP BY year,month
#   	     ORDER BY year,month")
# closed_monthly <- query(q)

q <- paste ("SELECT year(changed_on) * 12 + month (changed_on) AS id,
               year(changed_on) as year,
               month(changed_on) as month,
	       DATE_FORMAT (changed_on, '%b %Y') as date,
               count(changed_by) AS changed,
               count(distinct(changed_by)) AS changers
             FROM changes
             GROUP BY year,month
  	     ORDER BY year,month")
changed_monthly <- query(q)

issues_monthly <- merge (open_monthly, closed_monthly)
issues_monthly <- merge (issues_monthly, changed_monthly)

createJSON (issues_monthly, "../data/json/its-timeserie.json")



# Retrieve information about closed issues
res_issues_closed = dbGetQuery(con, "select DATEDIFF(delta_ts,submitted_on) as ttofix 
                               FROM issues, issues_ext_bugzilla 
                               WHERE issues.id = issues_ext_bugzilla.issue_id
                               AND status='RESOLVED';")

res_issues_w_closed=dbGetQuery(con, "SELECT DATE_FORMAT(delta_ts, '%Y%V') 
                                AS yearweek, COUNT(*) as nissues 
                                FROM issues, issues_ext_bugzilla 
                                WHERE issues.id = issues_ext_bugzilla.issue_id 
                                AND status='RESOLVED' 
                                GROUP BY yearweek;")

res_issues_w_open = dbGetQuery(con, "SELECT DATE_FORMAT(submitted_on, '%Y%V') 
                                    AS yearweek, COUNT(*) AS nissues 
                                    FROM issues GROUP BY yearweek")

# Disconnect from DB
dbDisconnect(con)

# Note use display.brewer.pal(...) to check colors
# example: display.brewer.pal(9, "Greens")

blues = brewer.pal(5,'Blues')
reds = brewer.pal(5,'Reds')
greens = brewer.pal(5,'Greens')


## TIME TO FIX

pdf('its-distrib_time_to_fix.pdf', height=3.5, width=5)
hist(res_issues_closed$ttofix, prob= T, breaks='FD', col=blues[3],
     xlab = 'Time to fix (days)', main = 'Time to fix bugs (kdevelop)')
lines(density(res_issues_closed$ttofix), col=reds[3], lwd = 2)
dev.off()

pdf('its-boxplot_time_to_fix.pdf', height=3.5, width=5)
boxplot(res_issues_closed$ttofix, col = greens[2],
        main = "Time to fix bugs", ylab = "days", xlab = "Kdevelop")

# Mark top 3 outliers
top3 = rev(sort(res_issues_closed$ttofix))[1:3]
print(top3)

text(rep(1,3), y = top3,
     label = paste(top3, 'days'), pos = 4)
dev.off()


## Evolution of open vs closed bugs

pdf('its-evolution-open-closed.pdf', height=3.5, width=5)
plot(res_issues_w_closed$nissues, type="l", xlab="Weeks", ylab="bugs", 
     main="Open  and closed bugs", col=greens[3])
# trick: some weeks of closed bugs are empty so we have less row in that var
lines(res_issues_w_open$nissues, type="l", col=reds[3])
legend(1, 600, c("Closed","Open"),  
       col=c(greens[3],reds[3]), lty=1:1)
dev.off()
